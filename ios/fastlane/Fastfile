# 한코한코 iOS Fastlane 설정
# 문서: https://docs.fastlane.tools

default_platform(:ios)

platform :ios do

  # ==================== 공통 헬퍼 ====================

  private_lane :app_identifier_value do
    "com.hankohanko.hankoHanko"
  end

  private_lane :required_privacy_keys do
    {
      "NSMicrophoneUsageDescription" => "마이크 접근 사유",
      "NSSpeechRecognitionUsageDescription" => "음성 인식 사용 사유",
      "NSPhotoLibraryUsageDescription" => "사진 보관함 접근 사유",
      "NSPhotoLibraryAddUsageDescription" => "사진 보관함 저장 사유"
    }
  end

  private_lane :app_store_api_key do
    app_store_connect_api_key(
      key_id: ENV["APP_STORE_CONNECT_API_KEY_ID"],
      issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
      key_filepath: ENV["APP_STORE_CONNECT_API_KEY_PATH"],
      in_house: false
    )
  end

  private_lane :ensure_flutter_dependencies do
    Dir.chdir("..") do
      sh("cd .. && flutter pub get")
    end
  end

  private_lane :build_flutter_ios_release do
    ensure_flutter_dependencies

    Dir.chdir("..") do
      sh("cd .. && flutter build ios --release " \
           "--dart-define=IOS_INTERSTITIAL_ID=#{ENV['IOS_INTERSTITIAL_ID']} " \
           "--dart-define=IOS_REWARDED_ID=#{ENV['IOS_REWARDED_ID']} " \
           "--dart-define=IOS_BANNER_ID=#{ENV['IOS_BANNER_ID']}")
    end
  end

  private_lane :pubspec_version_info do
    pubspec_path = File.expand_path("../../pubspec.yaml", __dir__)
    version_line = File.readlines(pubspec_path).find { |line| line.strip.start_with?("version:") }
    UI.user_error!("pubspec.yaml에 version 항목이 없습니다.") unless version_line

    raw = version_line.split(":", 2).last.strip
    match = raw.match(/\A(\d+\.\d+\.\d+)\+(\d+)\z/)
    UI.user_error!("pubspec version 형식은 X.Y.Z+N 이어야 합니다. 현재: #{raw}") unless match

    {
      raw: raw,
      version: match[1],
      build: match[2].to_i
    }
  end

  private_lane :assert_required_privacy_strings do
    plist_path = File.expand_path("../Runner/Info.plist", __dir__)
    sh("plutil -lint #{plist_path}")

    missing_keys = required_privacy_keys.keys.select do |key|
      begin
        value = get_info_plist_value(path: plist_path, key: key)
        value.to_s.strip.empty?
      rescue
        true
      end
    end

    unless missing_keys.empty?
      messages = missing_keys.map { |key| "#{key} (#{required_privacy_keys[key]})" }
      UI.user_error!("Info.plist 필수 privacy key 누락: #{messages.join(', ')}")
    end
  end

  private_lane :assert_flutter_build_number_binding do
    expected = "$(FLUTTER_BUILD_NUMBER)"
    plist_path = File.expand_path("../Runner/Info.plist", __dir__)
    actual = get_info_plist_value(path: plist_path, key: "CFBundleVersion")

    unless actual.to_s == expected
      UI.user_error!("Runner/Info.plist의 CFBundleVersion은 #{expected} 이어야 합니다. 현재: #{actual}")
    end
  end

  private_lane :assert_build_number_is_new do |options|
    latest_build = nil

    begin
      latest_build = latest_testflight_build_number(
        app_identifier: app_identifier_value,
        version: options[:version],
        api_key: options[:api_key],
        live: false
      )
    rescue => e
      no_previous_build = e.message.include?("Could not find") || e.message.include?("Couldn't find")
      if no_previous_build
        UI.message("App Store Connect에 #{options[:version]} 기존 빌드가 없어 빌드 번호 검증을 건너뜁니다.")
      else
        raise
      end
    end

    if !latest_build.nil? && options[:build] <= latest_build.to_i
      UI.user_error!(
        "pubspec build 번호(#{options[:build]})는 App Store Connect 최신 빌드(#{latest_build})보다 커야 합니다."
      )
    end
  end

  # ==================== 배포 전 점검 ====================

  desc "iOS 배포 전 점검 (Info.plist, 버전/빌드, App Store Connect 빌드 번호)"
  lane :preflight do |options|
    info = pubspec_version_info
    target_version = options[:app_version] || info[:version]

    if target_version != info[:version]
      UI.user_error!("app_version=#{target_version} 이 pubspec 버전 #{info[:version]}과 다릅니다.")
    end

    assert_required_privacy_strings
    assert_flutter_build_number_binding

    api_env_ready = %w[
      APP_STORE_CONNECT_API_KEY_ID
      APP_STORE_CONNECT_ISSUER_ID
      APP_STORE_CONNECT_API_KEY_PATH
    ].all? { |key| !ENV[key].to_s.empty? }

    if options[:skip_remote_build_check] == true
      UI.important("skip_remote_build_check=true 이므로 원격 빌드 번호 검증을 건너뜁니다.")
    elsif api_env_ready
      assert_build_number_is_new(
        version: info[:version],
        build: info[:build],
        api_key: app_store_api_key
      )
    else
      UI.important("App Store API 환경변수가 없어 원격 빌드 번호 검증은 건너뜁니다.")
    end

    UI.success("Preflight 통과: #{info[:version]}+#{info[:build]}")
  end

  # ==================== 테스트 ====================

  desc "테스트 실행"
  lane :test do
    ensure_flutter_dependencies

    Dir.chdir("..") do
      sh("cd .. && flutter test")
    end
  end

  # ==================== 스크린샷 ====================

  desc "앱 스크린샷 캡처"
  lane :screenshots do
    capture_screenshots(
      workspace: "Runner.xcworkspace",
      scheme: "Runner"
    )
  end

  desc "스크린샷에 디바이스 프레임 적용"
  lane :frames do
    frameit(
      white: false,
      path: "./fastlane/screenshots"
    )
  end

  desc "스크린샷 캡처 + 프레임 적용"
  lane :screenshots_with_frames do
    screenshots
    frames
  end

  # ==================== 베타 배포 (TestFlight) ====================

  desc "TestFlight에 베타 버전 배포"
  lane :beta do
    api_key = app_store_api_key

    build_flutter_ios_release

    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "hankohanko.ipa",
      export_xcargs: "-allowProvisioningUpdates"
    )

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true
    )
  end

  # ==================== 프로덕션 배포 (App Store) ====================

  desc "App Store에 프로덕션 버전 배포 (기본: metadata 업로드 생략)"
  lane :release do |options|
    preflight(app_version: options[:app_version]) unless options[:skip_preflight] == true

    api_key = app_store_api_key
    skip_metadata_upload = options[:skip_metadata] != false

    build_flutter_ios_release

    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      export_method: "app-store",
      output_directory: "./build",
      output_name: "hankohanko.ipa",
      export_xcargs: "-allowProvisioningUpdates"
    )

    upload_to_app_store(
      api_key: api_key,
      app_version: options[:app_version],
      skip_screenshots: true,
      skip_metadata: skip_metadata_upload,
      submit_for_review: false,
      automatic_release: false,
      force: true,
      run_precheck_before_submit: false,
      precheck_include_in_app_purchases: false
    )
  end

  desc "업로드 + 심사 제출까지 한 번에 실행"
  lane :release_submit do |options|
    info = pubspec_version_info
    target_version = options[:app_version] || info[:version]

    preflight(app_version: target_version)
    release(
      app_version: target_version,
      skip_metadata: options[:skip_metadata],
      skip_preflight: true
    )
    submit_review(app_version: target_version)
  end

  desc "App Store에 스크린샷만 업로드"
  lane :upload_screenshots do |options|
    api_key = app_store_api_key

    deliver(
      api_key: api_key,
      skip_binary_upload: true,
      skip_metadata: options[:skip_metadata] != false,
      overwrite_screenshots: true,
      force: true,
      app_version: options[:app_version],
      precheck_include_in_app_purchases: false
    )
  end

  desc "App Store에 메타데이터만 업로드"
  lane :upload_metadata do |options|
    api_key = app_store_api_key

    deliver(
      api_key: api_key,
      app_version: options[:app_version],
      skip_binary_upload: true,
      skip_screenshots: true,
      force: true
    )
  end

  desc "App Store 심사 제출"
  lane :submit_review do |options|
    api_key = app_store_api_key

    begin
      deliver(
        api_key: api_key,
        skip_binary_upload: true,
        skip_screenshots: true,
        skip_metadata: true,
        submit_for_review: true,
        force: true,
        app_version: options[:app_version],
        run_precheck_before_submit: false,
        submission_information: {
          add_id_info_uses_idfa: false,
          export_compliance_uses_encryption: false,
          content_rights_contains_third_party_content: false
        }
      )
    rescue => e
      already_in_progress = e.message.include?("A review submission is already in progress")
      raise unless already_in_progress

      UI.important("이미 심사 제출이 진행 중입니다. 현재 상태를 성공으로 처리합니다.")
    end
  end

  # ==================== 인증서 관리 ====================

  desc "인증서 및 프로비저닝 프로파일 동기화 (match)"
  lane :sync_certs do
    match(
      type: "appstore",
      readonly: true
    )
  end

  desc "새 인증서 생성 (주의: 기존 인증서 무효화될 수 있음)"
  lane :create_certs do
    match(
      type: "appstore",
      force: true
    )
  end

  # ==================== 버전 관리 ====================

  desc "버전 번호 확인"
  lane :version do
    version = get_version_number(xcodeproj: "Runner.xcodeproj")
    build = get_build_number(xcodeproj: "Runner.xcodeproj")
    UI.message("현재 버전: #{version} (#{build})")
  end

  desc "버전 번호 증가 (major.minor.patch)"
  lane :bump_version do |options|
    increment_version_number(
      xcodeproj: "Runner.xcodeproj",
      bump_type: options[:type] || "patch"  # major, minor, patch
    )
  end

  # ==================== 유틸리티 ====================

  desc "App Store Connect API 키 설정 확인"
  lane :check_api_key do
    app_store_api_key
    UI.success("API 키 설정 완료!")
  end

  # ==================== 에러 핸들링 ====================

  error do |lane, exception|
    UI.error("Lane '#{lane}' 실패: #{exception.message}")
  end
end
